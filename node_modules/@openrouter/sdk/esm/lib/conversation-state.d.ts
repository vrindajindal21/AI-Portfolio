import type * as models from '../models/index.js';
import type { ConversationState, ParsedToolCall, Tool, TurnContext, UnsentToolResult } from './tool-types.js';
/**
 * Generate a unique ID for a conversation
 * Uses crypto.randomUUID if available, falls back to timestamp + random
 */
export declare function generateConversationId(): string;
/**
 * Create an initial conversation state
 * @param id - Optional custom ID, generates one if not provided
 */
export declare function createInitialState<TTools extends readonly Tool[] = readonly Tool[]>(id?: string): ConversationState<TTools>;
/**
 * Update a conversation state with new values
 * Automatically updates the updatedAt timestamp
 */
export declare function updateState<TTools extends readonly Tool[] = readonly Tool[]>(state: ConversationState<TTools>, updates: Partial<Omit<ConversationState<TTools>, 'id' | 'createdAt' | 'updatedAt'>>): ConversationState<TTools>;
/**
 * Append new items to the message history
 */
export declare function appendToMessages(current: models.OpenResponsesInput, newItems: models.OpenResponsesInput1[]): models.OpenResponsesInput;
/**
 * Check if a tool call requires approval
 * @param toolCall - The tool call to check
 * @param tools - Available tools
 * @param context - Turn context for the approval check
 * @param callLevelCheck - Optional call-level approval function (overrides tool-level), can be async
 */
export declare function toolRequiresApproval<TTools extends readonly Tool[]>(toolCall: ParsedToolCall<TTools[number]>, tools: TTools, context: TurnContext, callLevelCheck?: (toolCall: ParsedToolCall<TTools[number]>, context: TurnContext) => boolean | Promise<boolean>): Promise<boolean>;
/**
 * Partition tool calls into those requiring approval and those that can auto-execute
 * @param toolCalls - Tool calls to partition
 * @param tools - Available tools
 * @param context - Turn context for the approval check
 * @param callLevelCheck - Optional call-level approval function (overrides tool-level), can be async
 */
export declare function partitionToolCalls<TTools extends readonly Tool[]>(toolCalls: ParsedToolCall<TTools[number]>[], tools: TTools, context: TurnContext, callLevelCheck?: (toolCall: ParsedToolCall<TTools[number]>, context: TurnContext) => boolean | Promise<boolean>): Promise<{
    requiresApproval: ParsedToolCall<TTools[number]>[];
    autoExecute: ParsedToolCall<TTools[number]>[];
}>;
/**
 * Create an unsent tool result from a successful execution
 */
export declare function createUnsentResult<TTools extends readonly Tool[] = readonly Tool[]>(callId: string, name: string, output: unknown): UnsentToolResult<TTools>;
/**
 * Create an unsent tool result from a rejection
 */
export declare function createRejectedResult<TTools extends readonly Tool[] = readonly Tool[]>(callId: string, name: string, reason?: string): UnsentToolResult<TTools>;
/**
 * Convert unsent tool results to API format for sending to the model
 */
export declare function unsentResultsToAPIFormat(results: UnsentToolResult[]): models.OpenResponsesFunctionCallOutput[];
/**
 * Extract text content from a response
 */
export declare function extractTextFromResponse(response: models.OpenResponsesNonStreamingResponse): string;
/**
 * Extract tool calls from a response
 */
export declare function extractToolCallsFromResponse<TTools extends readonly Tool[]>(response: models.OpenResponsesNonStreamingResponse): ParsedToolCall<TTools[number]>[];
//# sourceMappingURL=conversation-state.d.ts.map