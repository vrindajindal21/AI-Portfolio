import * as z from "zod/v4";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
export type GetGenerationGlobals = {
    /**
     * The app identifier should be your app's URL and is used as the primary identifier for rankings.
     *
     * @remarks
     * This is used to track API usage per application.
     */
    httpReferer?: string | undefined;
    /**
     * The app display name allows you to customize how your app appears in OpenRouter's dashboard.
     *
     * @remarks
     */
    xTitle?: string | undefined;
};
export type GetGenerationRequest = {
    /**
     * The app identifier should be your app's URL and is used as the primary identifier for rankings.
     *
     * @remarks
     * This is used to track API usage per application.
     */
    httpReferer?: string | undefined;
    /**
     * The app display name allows you to customize how your app appears in OpenRouter's dashboard.
     *
     * @remarks
     */
    xTitle?: string | undefined;
    id: string;
};
/**
 * Type of API used for the generation
 */
export declare const ApiType: {
    readonly Completions: "completions";
    readonly Embeddings: "embeddings";
};
/**
 * Type of API used for the generation
 */
export type ApiType = OpenEnum<typeof ApiType>;
export declare const ProviderName: {
    readonly AnyScale: "AnyScale";
    readonly Atoma: "Atoma";
    readonly CentML: "Cent-ML";
    readonly CrofAI: "CrofAI";
    readonly Enfer: "Enfer";
    readonly GoPomelo: "GoPomelo";
    readonly HuggingFace: "HuggingFace";
    readonly Hyperbolic2: "Hyperbolic 2";
    readonly InoCloud: "InoCloud";
    readonly Kluster: "Kluster";
    readonly Lambda: "Lambda";
    readonly Lepton: "Lepton";
    readonly Lynn2: "Lynn 2";
    readonly Lynn: "Lynn";
    readonly Mancer: "Mancer";
    readonly Meta: "Meta";
    readonly Modal: "Modal";
    readonly Nineteen: "Nineteen";
    readonly OctoAI: "OctoAI";
    readonly Recursal: "Recursal";
    readonly Reflection: "Reflection";
    readonly Replicate: "Replicate";
    readonly SambaNova2: "SambaNova 2";
    readonly SFCompute: "SF Compute";
    readonly Targon: "Targon";
    readonly Together2: "Together 2";
    readonly Ubicloud: "Ubicloud";
    readonly OneDotAI: "01.AI";
    readonly Ai21: "AI21";
    readonly AionLabs: "AionLabs";
    readonly Alibaba: "Alibaba";
    readonly Ambient: "Ambient";
    readonly AmazonBedrock: "Amazon Bedrock";
    readonly AmazonNova: "Amazon Nova";
    readonly Anthropic: "Anthropic";
    readonly ArceeAI: "Arcee AI";
    readonly AtlasCloud: "AtlasCloud";
    readonly Avian: "Avian";
    readonly Azure: "Azure";
    readonly BaseTen: "BaseTen";
    readonly BytePlus: "BytePlus";
    readonly BlackForestLabs: "Black Forest Labs";
    readonly Cerebras: "Cerebras";
    readonly Chutes: "Chutes";
    readonly Cirrascale: "Cirrascale";
    readonly Clarifai: "Clarifai";
    readonly Cloudflare: "Cloudflare";
    readonly Cohere: "Cohere";
    readonly Crusoe: "Crusoe";
    readonly DeepInfra: "DeepInfra";
    readonly DeepSeek: "DeepSeek";
    readonly Featherless: "Featherless";
    readonly Fireworks: "Fireworks";
    readonly Friendli: "Friendli";
    readonly GMICloud: "GMICloud";
    readonly Google: "Google";
    readonly GoogleAIStudio: "Google AI Studio";
    readonly Groq: "Groq";
    readonly Hyperbolic: "Hyperbolic";
    readonly Inception: "Inception";
    readonly Inceptron: "Inceptron";
    readonly InferenceNet: "InferenceNet";
    readonly Infermatic: "Infermatic";
    readonly Inflection: "Inflection";
    readonly Liquid: "Liquid";
    readonly Mara: "Mara";
    readonly Mancer2: "Mancer 2";
    readonly Minimax: "Minimax";
    readonly ModelRun: "ModelRun";
    readonly Mistral: "Mistral";
    readonly Modular: "Modular";
    readonly MoonshotAI: "Moonshot AI";
    readonly Morph: "Morph";
    readonly NCompass: "NCompass";
    readonly Nebius: "Nebius";
    readonly NextBit: "NextBit";
    readonly Novita: "Novita";
    readonly Nvidia: "Nvidia";
    readonly OpenAI: "OpenAI";
    readonly OpenInference: "OpenInference";
    readonly Parasail: "Parasail";
    readonly Perplexity: "Perplexity";
    readonly Phala: "Phala";
    readonly Relace: "Relace";
    readonly SambaNova: "SambaNova";
    readonly Seed: "Seed";
    readonly SiliconFlow: "SiliconFlow";
    readonly Sourceful: "Sourceful";
    readonly StepFun: "StepFun";
    readonly Stealth: "Stealth";
    readonly StreamLake: "StreamLake";
    readonly Switchpoint: "Switchpoint";
    readonly Together: "Together";
    readonly Upstage: "Upstage";
    readonly Venice: "Venice";
    readonly WandB: "WandB";
    readonly Xiaomi: "Xiaomi";
    readonly XAI: "xAI";
    readonly ZAi: "Z.AI";
    readonly FakeProvider: "FakeProvider";
};
export type ProviderName = OpenEnum<typeof ProviderName>;
export type ProviderResponse = {
    id?: string | undefined;
    endpointId?: string | undefined;
    modelPermaslug?: string | undefined;
    providerName?: ProviderName | undefined;
    status: number | null;
    latency?: number | undefined;
    isByok?: boolean | undefined;
};
/**
 * Generation data
 */
export type GetGenerationData = {
    /**
     * Unique identifier for the generation
     */
    id: string;
    /**
     * Upstream provider's identifier for this generation
     */
    upstreamId: string | null;
    /**
     * Total cost of the generation in USD
     */
    totalCost: number;
    /**
     * Discount applied due to caching
     */
    cacheDiscount: number | null;
    /**
     * Cost charged by the upstream provider
     */
    upstreamInferenceCost: number | null;
    /**
     * ISO 8601 timestamp of when the generation was created
     */
    createdAt: string;
    /**
     * Model used for the generation
     */
    model: string;
    /**
     * ID of the app that made the request
     */
    appId: number | null;
    /**
     * Whether the response was streamed
     */
    streamed: boolean | null;
    /**
     * Whether the generation was cancelled
     */
    cancelled: boolean | null;
    /**
     * Name of the provider that served the request
     */
    providerName: string | null;
    /**
     * Total latency in milliseconds
     */
    latency: number | null;
    /**
     * Moderation latency in milliseconds
     */
    moderationLatency: number | null;
    /**
     * Time taken for generation in milliseconds
     */
    generationTime: number | null;
    /**
     * Reason the generation finished
     */
    finishReason: string | null;
    /**
     * Number of tokens in the prompt
     */
    tokensPrompt: number | null;
    /**
     * Number of tokens in the completion
     */
    tokensCompletion: number | null;
    /**
     * Native prompt tokens as reported by provider
     */
    nativeTokensPrompt: number | null;
    /**
     * Native completion tokens as reported by provider
     */
    nativeTokensCompletion: number | null;
    /**
     * Native completion image tokens as reported by provider
     */
    nativeTokensCompletionImages: number | null;
    /**
     * Native reasoning tokens as reported by provider
     */
    nativeTokensReasoning: number | null;
    /**
     * Native cached tokens as reported by provider
     */
    nativeTokensCached: number | null;
    /**
     * Number of media items in the prompt
     */
    numMediaPrompt: number | null;
    /**
     * Number of audio inputs in the prompt
     */
    numInputAudioPrompt: number | null;
    /**
     * Number of media items in the completion
     */
    numMediaCompletion: number | null;
    /**
     * Number of search results included
     */
    numSearchResults: number | null;
    /**
     * Origin URL of the request
     */
    origin: string;
    /**
     * Usage amount in USD
     */
    usage: number;
    /**
     * Whether this used bring-your-own-key
     */
    isByok: boolean;
    /**
     * Native finish reason as reported by provider
     */
    nativeFinishReason: string | null;
    /**
     * External user identifier
     */
    externalUser: string | null;
    /**
     * Type of API used for the generation
     */
    apiType: ApiType | null;
    /**
     * Router used for the request (e.g., openrouter/auto)
     */
    router: string | null;
    /**
     * List of provider responses for this generation, including fallback attempts
     */
    providerResponses: Array<ProviderResponse> | null;
};
/**
 * Generation response
 */
export type GetGenerationResponse = {
    /**
     * Generation data
     */
    data: GetGenerationData;
};
/** @internal */
export type GetGenerationRequest$Outbound = {
    "HTTP-Referer"?: string | undefined;
    "X-Title"?: string | undefined;
    id: string;
};
/** @internal */
export declare const GetGenerationRequest$outboundSchema: z.ZodType<GetGenerationRequest$Outbound, GetGenerationRequest>;
export declare function getGenerationRequestToJSON(getGenerationRequest: GetGenerationRequest): string;
/** @internal */
export declare const ApiType$inboundSchema: z.ZodType<ApiType, unknown>;
/** @internal */
export declare const ProviderName$inboundSchema: z.ZodType<ProviderName, unknown>;
/** @internal */
export declare const ProviderResponse$inboundSchema: z.ZodType<ProviderResponse, unknown>;
export declare function providerResponseFromJSON(jsonString: string): SafeParseResult<ProviderResponse, SDKValidationError>;
/** @internal */
export declare const GetGenerationData$inboundSchema: z.ZodType<GetGenerationData, unknown>;
export declare function getGenerationDataFromJSON(jsonString: string): SafeParseResult<GetGenerationData, SDKValidationError>;
/** @internal */
export declare const GetGenerationResponse$inboundSchema: z.ZodType<GetGenerationResponse, unknown>;
export declare function getGenerationResponseFromJSON(jsonString: string): SafeParseResult<GetGenerationResponse, SDKValidationError>;
//# sourceMappingURL=getgeneration.d.ts.map